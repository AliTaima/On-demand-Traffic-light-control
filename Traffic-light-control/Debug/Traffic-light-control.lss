
Traffic-light-control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000840  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000840  000008d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00800062  00800062  000008d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000008d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000908  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000178  00000000  00000000  00000944  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001725  00000000  00000000  00000abc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000095a  00000000  00000000  000021e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b57  00000000  00000000  00002b3b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002b8  00000000  00000000  00003694  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000668  00000000  00000000  0000394c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000007e6  00000000  00000000  00003fb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  0000479a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 6a 00 	jmp	0xd4	; 0xd4 <__vector_1>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 e4       	ldi	r30, 0x40	; 64
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a2 36       	cpi	r26, 0x62	; 98
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a2 e6       	ldi	r26, 0x62	; 98
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a4 36       	cpi	r26, 0x64	; 100
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 3b 02 	call	0x476	; 0x476 <main>
  8a:	0c 94 1e 04 	jmp	0x83c	; 0x83c <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <App_init>:
#include "application.h"
void App_init(void)
{
	// 1.  Set direction of LEDs to output
	// 1.1 cars' LEDs
	LED_init(LED_C_RED_PORT, LED_C_RED_PIN);
  92:	60 e0       	ldi	r22, 0x00	; 0
  94:	80 e0       	ldi	r24, 0x00	; 0
  96:	0e 94 2c 02 	call	0x458	; 0x458 <LED_init>
	LED_init(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
  9a:	61 e0       	ldi	r22, 0x01	; 1
  9c:	80 e0       	ldi	r24, 0x00	; 0
  9e:	0e 94 2c 02 	call	0x458	; 0x458 <LED_init>
	LED_init(LED_C_GREEN_PORT, LED_C_GREEN_PIN);
  a2:	62 e0       	ldi	r22, 0x02	; 2
  a4:	80 e0       	ldi	r24, 0x00	; 0
  a6:	0e 94 2c 02 	call	0x458	; 0x458 <LED_init>
	// 1.2 Pedestrians' LEDs
	LED_init(LED_P_RED_PORT, LED_P_RED_PIN);
  aa:	60 e0       	ldi	r22, 0x00	; 0
  ac:	81 e0       	ldi	r24, 0x01	; 1
  ae:	0e 94 2c 02 	call	0x458	; 0x458 <LED_init>
	LED_init(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN);
  b2:	61 e0       	ldi	r22, 0x01	; 1
  b4:	81 e0       	ldi	r24, 0x01	; 1
  b6:	0e 94 2c 02 	call	0x458	; 0x458 <LED_init>
	LED_init(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
  ba:	62 e0       	ldi	r22, 0x02	; 2
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	0e 94 2c 02 	call	0x458	; 0x458 <LED_init>
	// 2. Set direction of BUTTON  to input
	Button_init(EXT_INT_BUTTON_PORT, EXT_INT_BUTTON_PIN);
  c2:	62 e0       	ldi	r22, 0x02	; 2
  c4:	83 e0       	ldi	r24, 0x03	; 3
  c6:	0e 94 28 02 	call	0x450	; 0x450 <Button_init>
	// 3. initialize external interrupt 1
	interrupt_rising_init();
  ca:	0e 94 c5 03 	call	0x78a	; 0x78a <interrupt_rising_init>
	// 4. initialize timer
	TIMER_init();
  ce:	0e 94 cd 03 	call	0x79a	; 0x79a <TIMER_init>
  d2:	08 95       	ret

000000d4 <__vector_1>:
			PedestrianMode();
		}
	}
}
ISR(EXT_INT_0)
{
  d4:	1f 92       	push	r1
  d6:	0f 92       	push	r0
  d8:	0f b6       	in	r0, 0x3f	; 63
  da:	0f 92       	push	r0
  dc:	11 24       	eor	r1, r1
  de:	2f 93       	push	r18
  e0:	3f 93       	push	r19
  e2:	4f 93       	push	r20
  e4:	5f 93       	push	r21
  e6:	6f 93       	push	r22
  e8:	7f 93       	push	r23
  ea:	8f 93       	push	r24
  ec:	9f 93       	push	r25
  ee:	af 93       	push	r26
  f0:	bf 93       	push	r27
  f2:	ef 93       	push	r30
  f4:	ff 93       	push	r31
  f6:	cf 93       	push	r28
  f8:	df 93       	push	r29
  fa:	1f 92       	push	r1
  fc:	cd b7       	in	r28, 0x3d	; 61
  fe:	de b7       	in	r29, 0x3e	; 62
		3. turn on the interrupt state the indicate that the user can't implement the ISR again 
		until finish the first one

	*/ 
		// 1. check the color of cars' LED when the pedestrian push the button
	if (interrupt_state == INTERRUPT_OFF)
 100:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 104:	81 30       	cpi	r24, 0x01	; 1
 106:	19 f5       	brne	.+70     	; 0x14e <__vector_1+0x7a>
	{
		uint8_t value;
		DIO_read(LED_C_RED_PORT, LED_C_RED_PIN, &value);
 108:	ae 01       	movw	r20, r28
 10a:	4f 5f       	subi	r20, 0xFF	; 255
 10c:	5f 4f       	sbci	r21, 0xFF	; 255
 10e:	60 e0       	ldi	r22, 0x00	; 0
 110:	80 e0       	ldi	r24, 0x00	; 0
 112:	0e 94 64 03 	call	0x6c8	; 0x6c8 <DIO_read>
		if (value)
 116:	89 81       	ldd	r24, Y+1	; 0x01
 118:	88 23       	and	r24, r24
 11a:	19 f0       	breq	.+6      	; 0x122 <__vector_1+0x4e>
		{
			color = RED;
 11c:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <color>
 120:	11 c0       	rjmp	.+34     	; 0x144 <__vector_1+0x70>
		}
		else
		{
			DIO_read(LED_C_GREEN_PORT, LED_C_GREEN_PIN, &value);
 122:	ae 01       	movw	r20, r28
 124:	4f 5f       	subi	r20, 0xFF	; 255
 126:	5f 4f       	sbci	r21, 0xFF	; 255
 128:	62 e0       	ldi	r22, 0x02	; 2
 12a:	80 e0       	ldi	r24, 0x00	; 0
 12c:	0e 94 64 03 	call	0x6c8	; 0x6c8 <DIO_read>
			if (value)
 130:	89 81       	ldd	r24, Y+1	; 0x01
 132:	88 23       	and	r24, r24
 134:	21 f0       	breq	.+8      	; 0x13e <__vector_1+0x6a>
			{

				color = GREEN;
 136:	82 e0       	ldi	r24, 0x02	; 2
 138:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <color>
 13c:	03 c0       	rjmp	.+6      	; 0x144 <__vector_1+0x70>
			}
			else
			{
				color = YELLOW;
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <color>
			}
		}
		//	2. convert the mode from the normal to pedestrian mode
		mode = PEDESTRIAN;
 144:	81 e0       	ldi	r24, 0x01	; 1
 146:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__data_end>
		// 3. turn on the interrupt state the indicate that the user can't implement the ISR again
		interrupt_state = INTERRUPT_ON;
 14a:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
	}
}
 14e:	0f 90       	pop	r0
 150:	df 91       	pop	r29
 152:	cf 91       	pop	r28
 154:	ff 91       	pop	r31
 156:	ef 91       	pop	r30
 158:	bf 91       	pop	r27
 15a:	af 91       	pop	r26
 15c:	9f 91       	pop	r25
 15e:	8f 91       	pop	r24
 160:	7f 91       	pop	r23
 162:	6f 91       	pop	r22
 164:	5f 91       	pop	r21
 166:	4f 91       	pop	r20
 168:	3f 91       	pop	r19
 16a:	2f 91       	pop	r18
 16c:	0f 90       	pop	r0
 16e:	0f be       	out	0x3f, r0	; 63
 170:	0f 90       	pop	r0
 172:	1f 90       	pop	r1
 174:	18 95       	reti

00000176 <TurnOffLEDs>:
	/*
		Description:
		Turn off all the LEDs (for cars and pedestrians)
	*/
	// turn off all cars' LEDs
	LED_off(LED_C_RED_PORT, LED_C_RED_PIN);
 176:	60 e0       	ldi	r22, 0x00	; 0
 178:	80 e0       	ldi	r24, 0x00	; 0
 17a:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 17e:	61 e0       	ldi	r22, 0x01	; 1
 180:	80 e0       	ldi	r24, 0x00	; 0
 182:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_C_GREEN_PORT, LED_C_GREEN_PIN);
 186:	62 e0       	ldi	r22, 0x02	; 2
 188:	80 e0       	ldi	r24, 0x00	; 0
 18a:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	// turn off all pedestrian's LEDs
	LED_off(LED_P_RED_PORT, LED_P_RED_PIN);
 18e:	60 e0       	ldi	r22, 0x00	; 0
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN);
 196:	61 e0       	ldi	r22, 0x01	; 1
 198:	81 e0       	ldi	r24, 0x01	; 1
 19a:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
 19e:	62 e0       	ldi	r22, 0x02	; 2
 1a0:	81 e0       	ldi	r24, 0x01	; 1
 1a2:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
 1a6:	08 95       	ret

000001a8 <RedLED>:
	/*
		Description: 
		This function turn on cars' Red LED and Pedestrian's Green LED 
		To let pedestrians to pass the road
	*/
	LED_on(LED_C_RED_PORT, LED_C_RED_PIN);
 1a8:	60 e0       	ldi	r22, 0x00	; 0
 1aa:	80 e0       	ldi	r24, 0x00	; 0
 1ac:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	LED_on(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
 1b0:	62 e0       	ldi	r22, 0x02	; 2
 1b2:	81 e0       	ldi	r24, 0x01	; 1
 1b4:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	delay_5s();
 1b8:	0e 94 06 04 	call	0x80c	; 0x80c <delay_5s>
 1bc:	08 95       	ret

000001be <toggle_2_LEDs_5s>:
	LED_on(LED_C_RED_PORT, LED_C_RED_PIN);
	LED_on(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
	delay_5s();
}
void toggle_2_LEDs_5s(EN_port_t ledPort1, EN_pin_t ledPin1, EN_port_t ledPort2, EN_pin_t ledPin2)
{
 1be:	ef 92       	push	r14
 1c0:	ff 92       	push	r15
 1c2:	0f 93       	push	r16
 1c4:	1f 93       	push	r17
 1c6:	cf 93       	push	r28
 1c8:	df 93       	push	r29
 1ca:	e8 2e       	mov	r14, r24
 1cc:	f6 2e       	mov	r15, r22
 1ce:	04 2f       	mov	r16, r20
 1d0:	12 2f       	mov	r17, r18
		Description:
		make a delay for 5 seconds, and blink two LEDs during this duration
	*/
	uint32_t overflowCounter = 0;

	TCCR0 |= (1 << 2); // set pin2, 256 pre-scalar
 1d2:	83 b7       	in	r24, 0x33	; 51
 1d4:	84 60       	ori	r24, 0x04	; 4
 1d6:	83 bf       	out	0x33, r24	; 51
{
	/*
		Description:
		make a delay for 5 seconds, and blink two LEDs during this duration
	*/
	uint32_t overflowCounter = 0;
 1d8:	c0 e0       	ldi	r28, 0x00	; 0
 1da:	d0 e0       	ldi	r29, 0x00	; 0

	TCCR0 |= (1 << 2); // set pin2, 256 pre-scalar
	// Repeated number of overflow times
	while (overflowCounter < 77)
 1dc:	22 c0       	rjmp	.+68     	; 0x222 <toggle_2_LEDs_5s+0x64>
	{
		// wait the overflow flat to be set
		while ((TIFR & (1 << 0)) == 0)
 1de:	08 b6       	in	r0, 0x38	; 56
 1e0:	00 fe       	sbrs	r0, 0
 1e2:	fd cf       	rjmp	.-6      	; 0x1de <toggle_2_LEDs_5s+0x20>
			;
		// Clear the overflow flag
		TIFR |= (1 << 0);
 1e4:	88 b7       	in	r24, 0x38	; 56
 1e6:	81 60       	ori	r24, 0x01	; 1
 1e8:	88 bf       	out	0x38, r24	; 56
		if (overflowCounter % 6 == 0)
 1ea:	9e 01       	movw	r18, r28
 1ec:	ab ea       	ldi	r26, 0xAB	; 171
 1ee:	ba ea       	ldi	r27, 0xAA	; 170
 1f0:	0e 94 0f 04 	call	0x81e	; 0x81e <__umulhisi3>
 1f4:	96 95       	lsr	r25
 1f6:	87 95       	ror	r24
 1f8:	96 95       	lsr	r25
 1fa:	87 95       	ror	r24
 1fc:	9c 01       	movw	r18, r24
 1fe:	22 0f       	add	r18, r18
 200:	33 1f       	adc	r19, r19
 202:	82 0f       	add	r24, r18
 204:	93 1f       	adc	r25, r19
 206:	88 0f       	add	r24, r24
 208:	99 1f       	adc	r25, r25
 20a:	c8 17       	cp	r28, r24
 20c:	d9 07       	cpc	r29, r25
 20e:	41 f4       	brne	.+16     	; 0x220 <toggle_2_LEDs_5s+0x62>
		{
			LED_toggle(ledPort1, ledPin1);
 210:	6f 2d       	mov	r22, r15
 212:	8e 2d       	mov	r24, r14
 214:	0e 94 38 02 	call	0x470	; 0x470 <LED_toggle>
			LED_toggle(ledPort2, ledPin2);
 218:	61 2f       	mov	r22, r17
 21a:	80 2f       	mov	r24, r16
 21c:	0e 94 38 02 	call	0x470	; 0x470 <LED_toggle>
		}
		overflowCounter++;
 220:	21 96       	adiw	r28, 0x01	; 1
	*/
	uint32_t overflowCounter = 0;

	TCCR0 |= (1 << 2); // set pin2, 256 pre-scalar
	// Repeated number of overflow times
	while (overflowCounter < 77)
 222:	cd 34       	cpi	r28, 0x4D	; 77
 224:	d1 05       	cpc	r29, r1
 226:	d8 f2       	brcs	.-74     	; 0x1de <toggle_2_LEDs_5s+0x20>
			LED_toggle(ledPort1, ledPin1);
			LED_toggle(ledPort2, ledPin2);
		}
		overflowCounter++;
	}
}
 228:	df 91       	pop	r29
 22a:	cf 91       	pop	r28
 22c:	1f 91       	pop	r17
 22e:	0f 91       	pop	r16
 230:	ff 90       	pop	r15
 232:	ef 90       	pop	r14
 234:	08 95       	ret

00000236 <GreenLED>:
	1. turn on cars' Red LED and the pedestrian's Green LED
	2. then cars' Yellow LED and pedestrian's Yellow LED will be blink to tell the pedestrians 
	you should be ready to pass the road
	3. the cars' Red LED and the pedestrian's Green LED will be on( pedestrians will pass the road)
	*/
	LED_on(LED_C_GREEN_PORT, LED_C_GREEN_PIN);
 236:	62 e0       	ldi	r22, 0x02	; 2
 238:	80 e0       	ldi	r24, 0x00	; 0
 23a:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	LED_on(LED_P_RED_PORT, LED_P_RED_PIN);
 23e:	60 e0       	ldi	r22, 0x00	; 0
 240:	81 e0       	ldi	r24, 0x01	; 1
 242:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	delay_5s();
 246:	0e 94 06 04 	call	0x80c	; 0x80c <delay_5s>
	LED_off(LED_P_RED_PORT, LED_P_RED_PIN);
 24a:	60 e0       	ldi	r22, 0x00	; 0
 24c:	81 e0       	ldi	r24, 0x01	; 1
 24e:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	toggle_2_LEDs_5s(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN, LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 252:	21 e0       	ldi	r18, 0x01	; 1
 254:	40 e0       	ldi	r20, 0x00	; 0
 256:	61 e0       	ldi	r22, 0x01	; 1
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	0e 94 df 00 	call	0x1be	; 0x1be <toggle_2_LEDs_5s>
	LED_off(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN);
 25e:	61 e0       	ldi	r22, 0x01	; 1
 260:	81 e0       	ldi	r24, 0x01	; 1
 262:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 266:	61 e0       	ldi	r22, 0x01	; 1
 268:	80 e0       	ldi	r24, 0x00	; 0
 26a:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_C_GREEN_PORT, LED_C_GREEN_PIN);
 26e:	62 e0       	ldi	r22, 0x02	; 2
 270:	80 e0       	ldi	r24, 0x00	; 0
 272:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_on(LED_C_RED_PORT, LED_C_RED_PIN);
 276:	60 e0       	ldi	r22, 0x00	; 0
 278:	80 e0       	ldi	r24, 0x00	; 0
 27a:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	LED_on(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
 27e:	62 e0       	ldi	r22, 0x02	; 2
 280:	81 e0       	ldi	r24, 0x01	; 1
 282:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	delay_5s();
 286:	0e 94 06 04 	call	0x80c	; 0x80c <delay_5s>
 28a:	08 95       	ret

0000028c <toggle_LED_5s>:
		}
		overflowCounter++;
	}
}
void toggle_LED_5s(EN_port_t ledPort, EN_pin_t ledPin)
{
 28c:	0f 93       	push	r16
 28e:	1f 93       	push	r17
 290:	cf 93       	push	r28
 292:	df 93       	push	r29
 294:	08 2f       	mov	r16, r24
 296:	16 2f       	mov	r17, r22
		Description:
		make a delay for 5 seconds, and blink one LED during this duration
	*/
	uint32_t overflowCounter = 0;

	TCCR0 |= (1 << 2); // set pin2, 256 pre-scalar
 298:	83 b7       	in	r24, 0x33	; 51
 29a:	84 60       	ori	r24, 0x04	; 4
 29c:	83 bf       	out	0x33, r24	; 51
{
	/*
		Description:
		make a delay for 5 seconds, and blink one LED during this duration
	*/
	uint32_t overflowCounter = 0;
 29e:	c0 e0       	ldi	r28, 0x00	; 0
 2a0:	d0 e0       	ldi	r29, 0x00	; 0

	TCCR0 |= (1 << 2); // set pin2, 256 pre-scalar
	// Repeated number of overflow times
	while (overflowCounter < 77)
 2a2:	1e c0       	rjmp	.+60     	; 0x2e0 <toggle_LED_5s+0x54>
	{
		// wait the overflow flat to be set
		while ((TIFR & (1 << 0)) == 0)
 2a4:	08 b6       	in	r0, 0x38	; 56
 2a6:	00 fe       	sbrs	r0, 0
 2a8:	fd cf       	rjmp	.-6      	; 0x2a4 <toggle_LED_5s+0x18>
		;
		// Clear the overflow flag
		TIFR |= (1 << 0);
 2aa:	88 b7       	in	r24, 0x38	; 56
 2ac:	81 60       	ori	r24, 0x01	; 1
 2ae:	88 bf       	out	0x38, r24	; 56
		if (overflowCounter % 6 == 0)
 2b0:	9e 01       	movw	r18, r28
 2b2:	ab ea       	ldi	r26, 0xAB	; 171
 2b4:	ba ea       	ldi	r27, 0xAA	; 170
 2b6:	0e 94 0f 04 	call	0x81e	; 0x81e <__umulhisi3>
 2ba:	96 95       	lsr	r25
 2bc:	87 95       	ror	r24
 2be:	96 95       	lsr	r25
 2c0:	87 95       	ror	r24
 2c2:	9c 01       	movw	r18, r24
 2c4:	22 0f       	add	r18, r18
 2c6:	33 1f       	adc	r19, r19
 2c8:	82 0f       	add	r24, r18
 2ca:	93 1f       	adc	r25, r19
 2cc:	88 0f       	add	r24, r24
 2ce:	99 1f       	adc	r25, r25
 2d0:	c8 17       	cp	r28, r24
 2d2:	d9 07       	cpc	r29, r25
 2d4:	21 f4       	brne	.+8      	; 0x2de <toggle_LED_5s+0x52>
		{
			LED_toggle(ledPort, ledPin);
 2d6:	61 2f       	mov	r22, r17
 2d8:	80 2f       	mov	r24, r16
 2da:	0e 94 38 02 	call	0x470	; 0x470 <LED_toggle>
		}
		overflowCounter++;
 2de:	21 96       	adiw	r28, 0x01	; 1
	*/
	uint32_t overflowCounter = 0;

	TCCR0 |= (1 << 2); // set pin2, 256 pre-scalar
	// Repeated number of overflow times
	while (overflowCounter < 77)
 2e0:	cd 34       	cpi	r28, 0x4D	; 77
 2e2:	d1 05       	cpc	r29, r1
 2e4:	f8 f2       	brcs	.-66     	; 0x2a4 <toggle_LED_5s+0x18>
		{
			LED_toggle(ledPort, ledPin);
		}
		overflowCounter++;
	}
 2e6:	df 91       	pop	r29
 2e8:	cf 91       	pop	r28
 2ea:	1f 91       	pop	r17
 2ec:	0f 91       	pop	r16
 2ee:	08 95       	ret

000002f0 <YellowLED>:
	1. turn on cars' Red LED and blink pedestrian's Yellow LED
	2. then cars' Yellow LED and  pedestrian's Yellow LED will be blink to tell the pedestrians 
	you should be ready to pass the road
	3. the cars' Red LED and the pedestrian's Green LED will be on( pedestrians will pass the road)
	*/
	LED_on(LED_P_RED_PORT, LED_P_RED_PIN);
 2f0:	60 e0       	ldi	r22, 0x00	; 0
 2f2:	81 e0       	ldi	r24, 0x01	; 1
 2f4:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	toggle_LED_5s(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 2f8:	61 e0       	ldi	r22, 0x01	; 1
 2fa:	80 e0       	ldi	r24, 0x00	; 0
 2fc:	0e 94 46 01 	call	0x28c	; 0x28c <toggle_LED_5s>
	LED_off(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 300:	61 e0       	ldi	r22, 0x01	; 1
 302:	80 e0       	ldi	r24, 0x00	; 0
 304:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_P_RED_PORT, LED_P_RED_PIN);
 308:	60 e0       	ldi	r22, 0x00	; 0
 30a:	81 e0       	ldi	r24, 0x01	; 1
 30c:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	toggle_2_LEDs_5s(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN, LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 310:	21 e0       	ldi	r18, 0x01	; 1
 312:	40 e0       	ldi	r20, 0x00	; 0
 314:	61 e0       	ldi	r22, 0x01	; 1
 316:	81 e0       	ldi	r24, 0x01	; 1
 318:	0e 94 df 00 	call	0x1be	; 0x1be <toggle_2_LEDs_5s>
	LED_off(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN);
 31c:	61 e0       	ldi	r22, 0x01	; 1
 31e:	81 e0       	ldi	r24, 0x01	; 1
 320:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 324:	61 e0       	ldi	r22, 0x01	; 1
 326:	80 e0       	ldi	r24, 0x00	; 0
 328:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_on(LED_C_RED_PORT, LED_C_RED_PIN);
 32c:	60 e0       	ldi	r22, 0x00	; 0
 32e:	80 e0       	ldi	r24, 0x00	; 0
 330:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	LED_on(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
 334:	62 e0       	ldi	r22, 0x02	; 2
 336:	81 e0       	ldi	r24, 0x01	; 1
 338:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	delay_5s();
 33c:	0e 94 06 04 	call	0x80c	; 0x80c <delay_5s>
 340:	08 95       	ret

00000342 <PedestrianMode>:
		4.2 blink cars' Yellow LED and pedestrians' Yellow LED for 5 s
		4.3 Turn off Pedestrian's Yellow and Green LEDs and cars' Yellow LED
		4.4 Turn on cars' Red LED and the pedestrian's Green LED, to let cars pass 
	*/
	// 1. turn off all LEDs, to prevent the errors if it return from the pedestrian's mode
	TurnOffLEDs();
 342:	0e 94 bb 00 	call	0x176	; 0x176 <TurnOffLEDs>
	// 	2. check the color of cars' LED when the pedestrian push the button
	// 3. implement the mode according to the cars' LED color
	
	if (color == RED)
 346:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <color>
 34a:	81 11       	cpse	r24, r1
 34c:	03 c0       	rjmp	.+6      	; 0x354 <PedestrianMode+0x12>
	{
		RedLED();
 34e:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <RedLED>
 352:	09 c0       	rjmp	.+18     	; 0x366 <PedestrianMode+0x24>
	}
	else if (color == GREEN)
 354:	82 30       	cpi	r24, 0x02	; 2
 356:	19 f4       	brne	.+6      	; 0x35e <PedestrianMode+0x1c>
	{
		GreenLED();
 358:	0e 94 1b 01 	call	0x236	; 0x236 <GreenLED>
 35c:	04 c0       	rjmp	.+8      	; 0x366 <PedestrianMode+0x24>
	}
	else if (color == YELLOW)
 35e:	81 30       	cpi	r24, 0x01	; 1
 360:	11 f4       	brne	.+4      	; 0x366 <PedestrianMode+0x24>
	{
		YellowLED();
 362:	0e 94 78 01 	call	0x2f0	; 0x2f0 <YellowLED>
	}
	// 4. continue the pedestrian mode until led cars pass
	// 	4.1 turn off cars' Red LED
	LED_off(LED_C_RED_PORT, LED_C_RED_PIN);
 366:	60 e0       	ldi	r22, 0x00	; 0
 368:	80 e0       	ldi	r24, 0x00	; 0
 36a:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	// 	4.2 blink cars' Yellow LED and pedestrians' Yellow LED for 5 s
	toggle_2_LEDs_5s(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN, LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 36e:	21 e0       	ldi	r18, 0x01	; 1
 370:	40 e0       	ldi	r20, 0x00	; 0
 372:	61 e0       	ldi	r22, 0x01	; 1
 374:	81 e0       	ldi	r24, 0x01	; 1
 376:	0e 94 df 00 	call	0x1be	; 0x1be <toggle_2_LEDs_5s>
	//	4.3 Turn off Pedestrian's Yellow and Green LEDs and cars' Yellow LED

	LED_off(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
 37a:	62 e0       	ldi	r22, 0x02	; 2
 37c:	81 e0       	ldi	r24, 0x01	; 1
 37e:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN);
 382:	61 e0       	ldi	r22, 0x01	; 1
 384:	81 e0       	ldi	r24, 0x01	; 1
 386:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	LED_off(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 38a:	61 e0       	ldi	r22, 0x01	; 1
 38c:	80 e0       	ldi	r24, 0x00	; 0
 38e:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
	// 		4.4 Turn on cars' Red LED and the pedestrian's Green LED, to let cars pass
	LED_on(LED_P_RED_PORT, LED_P_RED_PIN);
 392:	60 e0       	ldi	r22, 0x00	; 0
 394:	81 e0       	ldi	r24, 0x01	; 1
 396:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	LED_on(LED_C_GREEN_PORT, LED_C_GREEN_PIN);
 39a:	62 e0       	ldi	r22, 0x02	; 2
 39c:	80 e0       	ldi	r24, 0x00	; 0
 39e:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
	delay_5s();
 3a2:	0e 94 06 04 	call	0x80c	; 0x80c <delay_5s>
	interrupt_state = INTERRUPT_OFF;
 3a6:	81 e0       	ldi	r24, 0x01	; 1
 3a8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
	mode = NORMAL;
 3ac:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <__data_end>
 3b0:	08 95       	ret

000003b2 <App_start>:
EN_interrupt_state_t interrupt_state = INTERRUPT_OFF;
void App_start(void)
{
	while (1)
	{
		if (mode == NORMAL)
 3b2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 3b6:	81 11       	cpse	r24, r1
 3b8:	45 c0       	rjmp	.+138    	; 0x444 <__EEPROM_REGION_LENGTH__+0x44>
				3.1 check if the user push the button during this duration or not, to call the pedestrian's mode
				4. Turn on cars' Green LED and blink the pedestrians' Yellow LED
			*/
			// 1. turn off all LEDs, to prevent the errors if it return from the pedestrian's mode
				
			TurnOffLEDs();
 3ba:	0e 94 bb 00 	call	0x176	; 0x176 <TurnOffLEDs>
			// 2. turn on cars' Red LED and the pedestrian's Green LED
			LED_on(LED_C_RED_PORT, LED_C_RED_PIN);
 3be:	60 e0       	ldi	r22, 0x00	; 0
 3c0:	80 e0       	ldi	r24, 0x00	; 0
 3c2:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
			LED_on(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
 3c6:	62 e0       	ldi	r22, 0x02	; 2
 3c8:	81 e0       	ldi	r24, 0x01	; 1
 3ca:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
			LED_off(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 3ce:	61 e0       	ldi	r22, 0x01	; 1
 3d0:	80 e0       	ldi	r24, 0x00	; 0
 3d2:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
			LED_off(LED_C_GREEN_PORT, LED_C_GREEN_PIN);
 3d6:	62 e0       	ldi	r22, 0x02	; 2
 3d8:	80 e0       	ldi	r24, 0x00	; 0
 3da:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
			delay_5s();
 3de:	0e 94 06 04 	call	0x80c	; 0x80c <delay_5s>
			// 2.1 check if the user push the button during this duration or not, to call the pedestrian's mode
			if (interrupt_state == INTERRUPT_ON)
 3e2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 3e6:	88 23       	and	r24, r24
 3e8:	21 f3       	breq	.-56     	; 0x3b2 <App_start>
			{
				continue;
			}
			// 3. blink cars' Yellow LED and turn on the pedestrians' Red LED
			LED_off(LED_C_RED_PORT, LED_C_RED_PIN);
 3ea:	60 e0       	ldi	r22, 0x00	; 0
 3ec:	80 e0       	ldi	r24, 0x00	; 0
 3ee:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
			LED_off(LED_P_GREEN_PORT, LED_P_GREEN_PIN);
 3f2:	62 e0       	ldi	r22, 0x02	; 2
 3f4:	81 e0       	ldi	r24, 0x01	; 1
 3f6:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
			LED_off(LED_C_GREEN_PORT, LED_C_GREEN_PIN);
 3fa:	62 e0       	ldi	r22, 0x02	; 2
 3fc:	80 e0       	ldi	r24, 0x00	; 0
 3fe:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
			LED_on(LED_P_RED_PORT, LED_P_RED_PIN);
 402:	60 e0       	ldi	r22, 0x00	; 0
 404:	81 e0       	ldi	r24, 0x01	; 1
 406:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
			toggle_LED_5s(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 40a:	61 e0       	ldi	r22, 0x01	; 1
 40c:	80 e0       	ldi	r24, 0x00	; 0
 40e:	0e 94 46 01 	call	0x28c	; 0x28c <toggle_LED_5s>
			//3.1 check if the user push the button during this duration or not, to call the pedestrian's mode
			if (interrupt_state == INTERRUPT_ON)
 412:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 416:	88 23       	and	r24, r24
 418:	61 f2       	breq	.-104    	; 0x3b2 <App_start>
			{
				continue;
			}
			//4. Turn on cars' Green LED and blink the pedestrians' Yellow LED
			LED_off(LED_P_RED_PORT, LED_P_RED_PIN);
 41a:	60 e0       	ldi	r22, 0x00	; 0
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
			LED_off(LED_C_RED_PORT, LED_C_RED_PIN);
 422:	60 e0       	ldi	r22, 0x00	; 0
 424:	80 e0       	ldi	r24, 0x00	; 0
 426:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
			LED_off(LED_C_YELLOW_PORT, LED_C_YELLOW_PIN);
 42a:	61 e0       	ldi	r22, 0x01	; 1
 42c:	80 e0       	ldi	r24, 0x00	; 0
 42e:	0e 94 34 02 	call	0x468	; 0x468 <LED_off>
			LED_on(LED_C_GREEN_PORT, LED_C_GREEN_PIN);
 432:	62 e0       	ldi	r22, 0x02	; 2
 434:	80 e0       	ldi	r24, 0x00	; 0
 436:	0e 94 30 02 	call	0x460	; 0x460 <LED_on>
			toggle_LED_5s(LED_P_YELLOW_PORT, LED_P_YELLOW_PIN);
 43a:	61 e0       	ldi	r22, 0x01	; 1
 43c:	81 e0       	ldi	r24, 0x01	; 1
 43e:	0e 94 46 01 	call	0x28c	; 0x28c <toggle_LED_5s>
 442:	b7 cf       	rjmp	.-146    	; 0x3b2 <App_start>
		}
		else if (mode == PEDESTRIAN)
 444:	81 30       	cpi	r24, 0x01	; 1
 446:	09 f0       	breq	.+2      	; 0x44a <__EEPROM_REGION_LENGTH__+0x4a>
 448:	b4 cf       	rjmp	.-152    	; 0x3b2 <App_start>
		{
			PedestrianMode();
 44a:	0e 94 a1 01 	call	0x342	; 0x342 <PedestrianMode>
 44e:	b1 cf       	rjmp	.-158    	; 0x3b2 <App_start>

00000450 <Button_init>:
#include "button.h"

//initialize
void Button_init(EN_port_t buttonPort, EN_pin_t buttonPin) // Button is an input device
{
	DIO_init(buttonPort, buttonPin, IN);
 450:	40 e0       	ldi	r20, 0x00	; 0
 452:	0e 94 42 02 	call	0x484	; 0x484 <DIO_init>
 456:	08 95       	ret

00000458 <LED_init>:
 */
#include "led.h"
void LED_init(EN_port_t ledPort, EN_pin_t ledPin)
{
	// let LED as output
	DIO_init(ledPort, ledPin, OUT);
 458:	41 e0       	ldi	r20, 0x01	; 1
 45a:	0e 94 42 02 	call	0x484	; 0x484 <DIO_init>
 45e:	08 95       	ret

00000460 <LED_on>:
}
void LED_on(EN_port_t ledPort, EN_pin_t ledPin)
{
	// write high on the LED
	DIO_write(ledPort, ledPin, HIGH);
 460:	41 e0       	ldi	r20, 0x01	; 1
 462:	0e 94 b9 02 	call	0x572	; 0x572 <DIO_write>
 466:	08 95       	ret

00000468 <LED_off>:
}
void LED_off(EN_port_t ledPort, EN_pin_t ledPin)
{
	// write low on the LED
	DIO_write(ledPort, ledPin, LOW);
 468:	40 e0       	ldi	r20, 0x00	; 0
 46a:	0e 94 b9 02 	call	0x572	; 0x572 <DIO_write>
 46e:	08 95       	ret

00000470 <LED_toggle>:
}
void LED_toggle(EN_port_t ledPort, EN_pin_t ledPin)
{
	// toggle the LED
	DIO_toggle(ledPort, ledPin);
 470:	0e 94 30 03 	call	0x660	; 0x660 <DIO_toggle>
 474:	08 95       	ret

00000476 <main>:

#include "Application/application.h"
int main(void)
{

	App_init();
 476:	0e 94 49 00 	call	0x92	; 0x92 <App_init>
	App_start();
 47a:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <App_start>
 	
}
 47e:	80 e0       	ldi	r24, 0x00	; 0
 480:	90 e0       	ldi	r25, 0x00	; 0
 482:	08 95       	ret

00000484 <DIO_init>:
		direction --> IN, OUT
		--------------------its task--------------------------------
		This function with initialize the direction of pin to be (inpu OR output)
	*/

	switch (portNumber)
 484:	81 30       	cpi	r24, 0x01	; 1
 486:	19 f1       	breq	.+70     	; 0x4ce <DIO_init+0x4a>
 488:	30 f0       	brcs	.+12     	; 0x496 <DIO_init+0x12>
 48a:	82 30       	cpi	r24, 0x02	; 2
 48c:	e1 f1       	breq	.+120    	; 0x506 <DIO_init+0x82>
 48e:	83 30       	cpi	r24, 0x03	; 3
 490:	09 f4       	brne	.+2      	; 0x494 <DIO_init+0x10>
 492:	54 c0       	rjmp	.+168    	; 0x53c <DIO_init+0xb8>
 494:	08 95       	ret
	{
	case PORT_A:
		if (direction == IN)
 496:	41 11       	cpse	r20, r1
 498:	0c c0       	rjmp	.+24     	; 0x4b2 <DIO_init+0x2e>
		{
			CLR_PIN(DDRA, pinNumber); // input
 49a:	2a b3       	in	r18, 0x1a	; 26
 49c:	81 e0       	ldi	r24, 0x01	; 1
 49e:	90 e0       	ldi	r25, 0x00	; 0
 4a0:	02 c0       	rjmp	.+4      	; 0x4a6 <DIO_init+0x22>
 4a2:	88 0f       	add	r24, r24
 4a4:	99 1f       	adc	r25, r25
 4a6:	6a 95       	dec	r22
 4a8:	e2 f7       	brpl	.-8      	; 0x4a2 <DIO_init+0x1e>
 4aa:	80 95       	com	r24
 4ac:	82 23       	and	r24, r18
 4ae:	8a bb       	out	0x1a, r24	; 26
 4b0:	08 95       	ret
		}
		else if (direction == OUT)
 4b2:	41 30       	cpi	r20, 0x01	; 1
 4b4:	09 f0       	breq	.+2      	; 0x4b8 <DIO_init+0x34>
 4b6:	5c c0       	rjmp	.+184    	; 0x570 <DIO_init+0xec>
		{
			SET_PIN(DDRA, pinNumber); // output
 4b8:	2a b3       	in	r18, 0x1a	; 26
 4ba:	81 e0       	ldi	r24, 0x01	; 1
 4bc:	90 e0       	ldi	r25, 0x00	; 0
 4be:	02 c0       	rjmp	.+4      	; 0x4c4 <DIO_init+0x40>
 4c0:	88 0f       	add	r24, r24
 4c2:	99 1f       	adc	r25, r25
 4c4:	6a 95       	dec	r22
 4c6:	e2 f7       	brpl	.-8      	; 0x4c0 <DIO_init+0x3c>
 4c8:	82 2b       	or	r24, r18
 4ca:	8a bb       	out	0x1a, r24	; 26
 4cc:	08 95       	ret
		}

		break;
	case PORT_B:
		if (direction == IN)
 4ce:	41 11       	cpse	r20, r1
 4d0:	0c c0       	rjmp	.+24     	; 0x4ea <DIO_init+0x66>
		{
			CLR_PIN(DDRB, pinNumber); // input
 4d2:	27 b3       	in	r18, 0x17	; 23
 4d4:	81 e0       	ldi	r24, 0x01	; 1
 4d6:	90 e0       	ldi	r25, 0x00	; 0
 4d8:	02 c0       	rjmp	.+4      	; 0x4de <DIO_init+0x5a>
 4da:	88 0f       	add	r24, r24
 4dc:	99 1f       	adc	r25, r25
 4de:	6a 95       	dec	r22
 4e0:	e2 f7       	brpl	.-8      	; 0x4da <DIO_init+0x56>
 4e2:	80 95       	com	r24
 4e4:	82 23       	and	r24, r18
 4e6:	87 bb       	out	0x17, r24	; 23
 4e8:	08 95       	ret
		}
		else if (direction == OUT)
 4ea:	41 30       	cpi	r20, 0x01	; 1
 4ec:	09 f0       	breq	.+2      	; 0x4f0 <DIO_init+0x6c>
 4ee:	40 c0       	rjmp	.+128    	; 0x570 <DIO_init+0xec>
		{
			SET_PIN(DDRB, pinNumber); // output
 4f0:	27 b3       	in	r18, 0x17	; 23
 4f2:	81 e0       	ldi	r24, 0x01	; 1
 4f4:	90 e0       	ldi	r25, 0x00	; 0
 4f6:	02 c0       	rjmp	.+4      	; 0x4fc <DIO_init+0x78>
 4f8:	88 0f       	add	r24, r24
 4fa:	99 1f       	adc	r25, r25
 4fc:	6a 95       	dec	r22
 4fe:	e2 f7       	brpl	.-8      	; 0x4f8 <DIO_init+0x74>
 500:	82 2b       	or	r24, r18
 502:	87 bb       	out	0x17, r24	; 23
 504:	08 95       	ret
		}

		break;
	case PORT_C:
		if (direction == IN)
 506:	41 11       	cpse	r20, r1
 508:	0c c0       	rjmp	.+24     	; 0x522 <DIO_init+0x9e>
		{
			CLR_PIN(DDRC, pinNumber); // input
 50a:	24 b3       	in	r18, 0x14	; 20
 50c:	81 e0       	ldi	r24, 0x01	; 1
 50e:	90 e0       	ldi	r25, 0x00	; 0
 510:	02 c0       	rjmp	.+4      	; 0x516 <DIO_init+0x92>
 512:	88 0f       	add	r24, r24
 514:	99 1f       	adc	r25, r25
 516:	6a 95       	dec	r22
 518:	e2 f7       	brpl	.-8      	; 0x512 <DIO_init+0x8e>
 51a:	80 95       	com	r24
 51c:	82 23       	and	r24, r18
 51e:	84 bb       	out	0x14, r24	; 20
 520:	08 95       	ret
		}
		else if (direction == OUT)
 522:	41 30       	cpi	r20, 0x01	; 1
 524:	29 f5       	brne	.+74     	; 0x570 <DIO_init+0xec>
		{
			SET_PIN(DDRC, pinNumber); // output
 526:	24 b3       	in	r18, 0x14	; 20
 528:	81 e0       	ldi	r24, 0x01	; 1
 52a:	90 e0       	ldi	r25, 0x00	; 0
 52c:	02 c0       	rjmp	.+4      	; 0x532 <DIO_init+0xae>
 52e:	88 0f       	add	r24, r24
 530:	99 1f       	adc	r25, r25
 532:	6a 95       	dec	r22
 534:	e2 f7       	brpl	.-8      	; 0x52e <DIO_init+0xaa>
 536:	82 2b       	or	r24, r18
 538:	84 bb       	out	0x14, r24	; 20
 53a:	08 95       	ret
		}

		break;
	case PORT_D:
		if (direction == IN)
 53c:	41 11       	cpse	r20, r1
 53e:	0c c0       	rjmp	.+24     	; 0x558 <DIO_init+0xd4>
		{
			CLR_PIN(DDRD, pinNumber); // input
 540:	21 b3       	in	r18, 0x11	; 17
 542:	81 e0       	ldi	r24, 0x01	; 1
 544:	90 e0       	ldi	r25, 0x00	; 0
 546:	02 c0       	rjmp	.+4      	; 0x54c <DIO_init+0xc8>
 548:	88 0f       	add	r24, r24
 54a:	99 1f       	adc	r25, r25
 54c:	6a 95       	dec	r22
 54e:	e2 f7       	brpl	.-8      	; 0x548 <DIO_init+0xc4>
 550:	80 95       	com	r24
 552:	82 23       	and	r24, r18
 554:	81 bb       	out	0x11, r24	; 17
 556:	08 95       	ret
		}
		else if (direction == OUT)
 558:	41 30       	cpi	r20, 0x01	; 1
 55a:	51 f4       	brne	.+20     	; 0x570 <DIO_init+0xec>
		{
			SET_PIN(DDRD, pinNumber); // output
 55c:	21 b3       	in	r18, 0x11	; 17
 55e:	81 e0       	ldi	r24, 0x01	; 1
 560:	90 e0       	ldi	r25, 0x00	; 0
 562:	02 c0       	rjmp	.+4      	; 0x568 <DIO_init+0xe4>
 564:	88 0f       	add	r24, r24
 566:	99 1f       	adc	r25, r25
 568:	6a 95       	dec	r22
 56a:	e2 f7       	brpl	.-8      	; 0x564 <DIO_init+0xe0>
 56c:	82 2b       	or	r24, r18
 56e:	81 bb       	out	0x11, r24	; 17
 570:	08 95       	ret

00000572 <DIO_write>:
		pinNumber --> PIN0, PIN1, PIN2, PIN3, PIN4, PIN5, PIN6, PIN7
		value --> LOW, HIGH
		--------------------its task--------------------------------
		This function write 1 or 0 on the pinNumber
	*/
	switch (portNumber)
 572:	81 30       	cpi	r24, 0x01	; 1
 574:	19 f1       	breq	.+70     	; 0x5bc <DIO_write+0x4a>
 576:	30 f0       	brcs	.+12     	; 0x584 <DIO_write+0x12>
 578:	82 30       	cpi	r24, 0x02	; 2
 57a:	e1 f1       	breq	.+120    	; 0x5f4 <DIO_write+0x82>
 57c:	83 30       	cpi	r24, 0x03	; 3
 57e:	09 f4       	brne	.+2      	; 0x582 <DIO_write+0x10>
 580:	54 c0       	rjmp	.+168    	; 0x62a <DIO_write+0xb8>
 582:	08 95       	ret
	{
	case PORT_A:
		if (value == LOW)
 584:	41 11       	cpse	r20, r1
 586:	0c c0       	rjmp	.+24     	; 0x5a0 <DIO_write+0x2e>
		{
			CLR_PIN(PORTA, pinNumber); // write 0
 588:	2b b3       	in	r18, 0x1b	; 27
 58a:	81 e0       	ldi	r24, 0x01	; 1
 58c:	90 e0       	ldi	r25, 0x00	; 0
 58e:	02 c0       	rjmp	.+4      	; 0x594 <DIO_write+0x22>
 590:	88 0f       	add	r24, r24
 592:	99 1f       	adc	r25, r25
 594:	6a 95       	dec	r22
 596:	e2 f7       	brpl	.-8      	; 0x590 <DIO_write+0x1e>
 598:	80 95       	com	r24
 59a:	82 23       	and	r24, r18
 59c:	8b bb       	out	0x1b, r24	; 27
 59e:	08 95       	ret
		}
		else if (value == HIGH)
 5a0:	41 30       	cpi	r20, 0x01	; 1
 5a2:	09 f0       	breq	.+2      	; 0x5a6 <DIO_write+0x34>
 5a4:	5c c0       	rjmp	.+184    	; 0x65e <DIO_write+0xec>
		{
			SET_PIN(PORTA, pinNumber); // write 1
 5a6:	2b b3       	in	r18, 0x1b	; 27
 5a8:	81 e0       	ldi	r24, 0x01	; 1
 5aa:	90 e0       	ldi	r25, 0x00	; 0
 5ac:	02 c0       	rjmp	.+4      	; 0x5b2 <DIO_write+0x40>
 5ae:	88 0f       	add	r24, r24
 5b0:	99 1f       	adc	r25, r25
 5b2:	6a 95       	dec	r22
 5b4:	e2 f7       	brpl	.-8      	; 0x5ae <DIO_write+0x3c>
 5b6:	82 2b       	or	r24, r18
 5b8:	8b bb       	out	0x1b, r24	; 27
 5ba:	08 95       	ret
		}

		break;
	case PORT_B:
		if (value == LOW)
 5bc:	41 11       	cpse	r20, r1
 5be:	0c c0       	rjmp	.+24     	; 0x5d8 <DIO_write+0x66>
		{
			CLR_PIN(PORTB, pinNumber); // write 0
 5c0:	28 b3       	in	r18, 0x18	; 24
 5c2:	81 e0       	ldi	r24, 0x01	; 1
 5c4:	90 e0       	ldi	r25, 0x00	; 0
 5c6:	02 c0       	rjmp	.+4      	; 0x5cc <DIO_write+0x5a>
 5c8:	88 0f       	add	r24, r24
 5ca:	99 1f       	adc	r25, r25
 5cc:	6a 95       	dec	r22
 5ce:	e2 f7       	brpl	.-8      	; 0x5c8 <DIO_write+0x56>
 5d0:	80 95       	com	r24
 5d2:	82 23       	and	r24, r18
 5d4:	88 bb       	out	0x18, r24	; 24
 5d6:	08 95       	ret
		}
		else if (value == HIGH)
 5d8:	41 30       	cpi	r20, 0x01	; 1
 5da:	09 f0       	breq	.+2      	; 0x5de <DIO_write+0x6c>
 5dc:	40 c0       	rjmp	.+128    	; 0x65e <DIO_write+0xec>
		{
			SET_PIN(PORTB, pinNumber); // write 1
 5de:	28 b3       	in	r18, 0x18	; 24
 5e0:	81 e0       	ldi	r24, 0x01	; 1
 5e2:	90 e0       	ldi	r25, 0x00	; 0
 5e4:	02 c0       	rjmp	.+4      	; 0x5ea <DIO_write+0x78>
 5e6:	88 0f       	add	r24, r24
 5e8:	99 1f       	adc	r25, r25
 5ea:	6a 95       	dec	r22
 5ec:	e2 f7       	brpl	.-8      	; 0x5e6 <DIO_write+0x74>
 5ee:	82 2b       	or	r24, r18
 5f0:	88 bb       	out	0x18, r24	; 24
 5f2:	08 95       	ret
		}

		break;
	case PORT_C:
		if (value == LOW)
 5f4:	41 11       	cpse	r20, r1
 5f6:	0c c0       	rjmp	.+24     	; 0x610 <DIO_write+0x9e>
		{
			CLR_PIN(PORTC, pinNumber); // write 0
 5f8:	25 b3       	in	r18, 0x15	; 21
 5fa:	81 e0       	ldi	r24, 0x01	; 1
 5fc:	90 e0       	ldi	r25, 0x00	; 0
 5fe:	02 c0       	rjmp	.+4      	; 0x604 <DIO_write+0x92>
 600:	88 0f       	add	r24, r24
 602:	99 1f       	adc	r25, r25
 604:	6a 95       	dec	r22
 606:	e2 f7       	brpl	.-8      	; 0x600 <DIO_write+0x8e>
 608:	80 95       	com	r24
 60a:	82 23       	and	r24, r18
 60c:	85 bb       	out	0x15, r24	; 21
 60e:	08 95       	ret
		}
		else if (value == HIGH)
 610:	41 30       	cpi	r20, 0x01	; 1
 612:	29 f5       	brne	.+74     	; 0x65e <DIO_write+0xec>
		{
			SET_PIN(PORTC, pinNumber); // write 1
 614:	25 b3       	in	r18, 0x15	; 21
 616:	81 e0       	ldi	r24, 0x01	; 1
 618:	90 e0       	ldi	r25, 0x00	; 0
 61a:	02 c0       	rjmp	.+4      	; 0x620 <DIO_write+0xae>
 61c:	88 0f       	add	r24, r24
 61e:	99 1f       	adc	r25, r25
 620:	6a 95       	dec	r22
 622:	e2 f7       	brpl	.-8      	; 0x61c <DIO_write+0xaa>
 624:	82 2b       	or	r24, r18
 626:	85 bb       	out	0x15, r24	; 21
 628:	08 95       	ret
		}

		break;
	case PORT_D:
		if (value == LOW)
 62a:	41 11       	cpse	r20, r1
 62c:	0c c0       	rjmp	.+24     	; 0x646 <DIO_write+0xd4>
		{
			CLR_PIN(PORTD, pinNumber); // write 0
 62e:	22 b3       	in	r18, 0x12	; 18
 630:	81 e0       	ldi	r24, 0x01	; 1
 632:	90 e0       	ldi	r25, 0x00	; 0
 634:	02 c0       	rjmp	.+4      	; 0x63a <DIO_write+0xc8>
 636:	88 0f       	add	r24, r24
 638:	99 1f       	adc	r25, r25
 63a:	6a 95       	dec	r22
 63c:	e2 f7       	brpl	.-8      	; 0x636 <DIO_write+0xc4>
 63e:	80 95       	com	r24
 640:	82 23       	and	r24, r18
 642:	82 bb       	out	0x12, r24	; 18
 644:	08 95       	ret
		}
		else if (value == HIGH)
 646:	41 30       	cpi	r20, 0x01	; 1
 648:	51 f4       	brne	.+20     	; 0x65e <DIO_write+0xec>
		{
			SET_PIN(PORTD, pinNumber); // write 1
 64a:	22 b3       	in	r18, 0x12	; 18
 64c:	81 e0       	ldi	r24, 0x01	; 1
 64e:	90 e0       	ldi	r25, 0x00	; 0
 650:	02 c0       	rjmp	.+4      	; 0x656 <DIO_write+0xe4>
 652:	88 0f       	add	r24, r24
 654:	99 1f       	adc	r25, r25
 656:	6a 95       	dec	r22
 658:	e2 f7       	brpl	.-8      	; 0x652 <DIO_write+0xe0>
 65a:	82 2b       	or	r24, r18
 65c:	82 bb       	out	0x12, r24	; 18
 65e:	08 95       	ret

00000660 <DIO_toggle>:
		portNumber --> PORT_A, PORT_B, PORT_C, PORT_D
		pinNumber --> PIN0, PIN1, PIN2, PIN3, PIN4, PIN5, PIN6, PIN7
		--------------------its task--------------------------------
		This function toggle the state of the pin (if it 0 it makes it 1, if it 1 it makes it 0)
	*/
	switch (portNumber)
 660:	81 30       	cpi	r24, 0x01	; 1
 662:	89 f0       	breq	.+34     	; 0x686 <DIO_toggle+0x26>
 664:	28 f0       	brcs	.+10     	; 0x670 <DIO_toggle+0x10>
 666:	82 30       	cpi	r24, 0x02	; 2
 668:	c9 f0       	breq	.+50     	; 0x69c <DIO_toggle+0x3c>
 66a:	83 30       	cpi	r24, 0x03	; 3
 66c:	11 f1       	breq	.+68     	; 0x6b2 <DIO_toggle+0x52>
 66e:	08 95       	ret
	{
	case PORT_A:
		TOGGLE_PIN(PORTA, pinNumber);
 670:	2b b3       	in	r18, 0x1b	; 27
 672:	81 e0       	ldi	r24, 0x01	; 1
 674:	90 e0       	ldi	r25, 0x00	; 0
 676:	02 c0       	rjmp	.+4      	; 0x67c <DIO_toggle+0x1c>
 678:	88 0f       	add	r24, r24
 67a:	99 1f       	adc	r25, r25
 67c:	6a 95       	dec	r22
 67e:	e2 f7       	brpl	.-8      	; 0x678 <DIO_toggle+0x18>
 680:	82 27       	eor	r24, r18
 682:	8b bb       	out	0x1b, r24	; 27
		break;
 684:	08 95       	ret
	case PORT_B:
		TOGGLE_PIN(PORTB, pinNumber);
 686:	28 b3       	in	r18, 0x18	; 24
 688:	81 e0       	ldi	r24, 0x01	; 1
 68a:	90 e0       	ldi	r25, 0x00	; 0
 68c:	02 c0       	rjmp	.+4      	; 0x692 <DIO_toggle+0x32>
 68e:	88 0f       	add	r24, r24
 690:	99 1f       	adc	r25, r25
 692:	6a 95       	dec	r22
 694:	e2 f7       	brpl	.-8      	; 0x68e <DIO_toggle+0x2e>
 696:	82 27       	eor	r24, r18
 698:	88 bb       	out	0x18, r24	; 24
		break;
 69a:	08 95       	ret
	case PORT_C:
		TOGGLE_PIN(PORTC, pinNumber);
 69c:	25 b3       	in	r18, 0x15	; 21
 69e:	81 e0       	ldi	r24, 0x01	; 1
 6a0:	90 e0       	ldi	r25, 0x00	; 0
 6a2:	02 c0       	rjmp	.+4      	; 0x6a8 <DIO_toggle+0x48>
 6a4:	88 0f       	add	r24, r24
 6a6:	99 1f       	adc	r25, r25
 6a8:	6a 95       	dec	r22
 6aa:	e2 f7       	brpl	.-8      	; 0x6a4 <DIO_toggle+0x44>
 6ac:	82 27       	eor	r24, r18
 6ae:	85 bb       	out	0x15, r24	; 21
		break;
 6b0:	08 95       	ret
	case PORT_D:
		TOGGLE_PIN(PORTD, pinNumber);
 6b2:	22 b3       	in	r18, 0x12	; 18
 6b4:	81 e0       	ldi	r24, 0x01	; 1
 6b6:	90 e0       	ldi	r25, 0x00	; 0
 6b8:	02 c0       	rjmp	.+4      	; 0x6be <DIO_toggle+0x5e>
 6ba:	88 0f       	add	r24, r24
 6bc:	99 1f       	adc	r25, r25
 6be:	6a 95       	dec	r22
 6c0:	e2 f7       	brpl	.-8      	; 0x6ba <DIO_toggle+0x5a>
 6c2:	82 27       	eor	r24, r18
 6c4:	82 bb       	out	0x12, r24	; 18
 6c6:	08 95       	ret

000006c8 <DIO_read>:
		pinNumber --> PIN0, PIN1, PIN2, PIN3, PIN4, PIN5, PIN6, PIN7
		*value --> pointer store the status on the variable that it point to
		--------------------its task--------------------------------
		This function read the state of pinNumber and store it in *value pointer
	*/
	switch (portNumber)
 6c8:	81 30       	cpi	r24, 0x01	; 1
 6ca:	e9 f0       	breq	.+58     	; 0x706 <DIO_read+0x3e>
 6cc:	30 f0       	brcs	.+12     	; 0x6da <DIO_read+0x12>
 6ce:	82 30       	cpi	r24, 0x02	; 2
 6d0:	81 f1       	breq	.+96     	; 0x732 <DIO_read+0x6a>
 6d2:	83 30       	cpi	r24, 0x03	; 3
 6d4:	09 f4       	brne	.+2      	; 0x6d8 <DIO_read+0x10>
 6d6:	43 c0       	rjmp	.+134    	; 0x75e <DIO_read+0x96>
 6d8:	08 95       	ret
	{
	case PORT_A:
		GET_STATE(*value, PINA, pinNumber); // get state --> read bit
 6da:	79 b3       	in	r23, 0x19	; 25
 6dc:	81 e0       	ldi	r24, 0x01	; 1
 6de:	90 e0       	ldi	r25, 0x00	; 0
 6e0:	9c 01       	movw	r18, r24
 6e2:	06 2e       	mov	r0, r22
 6e4:	02 c0       	rjmp	.+4      	; 0x6ea <DIO_read+0x22>
 6e6:	22 0f       	add	r18, r18
 6e8:	33 1f       	adc	r19, r19
 6ea:	0a 94       	dec	r0
 6ec:	e2 f7       	brpl	.-8      	; 0x6e6 <DIO_read+0x1e>
 6ee:	87 2f       	mov	r24, r23
 6f0:	90 e0       	ldi	r25, 0x00	; 0
 6f2:	82 23       	and	r24, r18
 6f4:	93 23       	and	r25, r19
 6f6:	02 c0       	rjmp	.+4      	; 0x6fc <DIO_read+0x34>
 6f8:	95 95       	asr	r25
 6fa:	87 95       	ror	r24
 6fc:	6a 95       	dec	r22
 6fe:	e2 f7       	brpl	.-8      	; 0x6f8 <DIO_read+0x30>
 700:	fa 01       	movw	r30, r20
 702:	80 83       	st	Z, r24
		break;
 704:	08 95       	ret
	case PORT_B:
		GET_STATE(*value, PINB, pinNumber); // get state --> read bit
 706:	76 b3       	in	r23, 0x16	; 22
 708:	81 e0       	ldi	r24, 0x01	; 1
 70a:	90 e0       	ldi	r25, 0x00	; 0
 70c:	9c 01       	movw	r18, r24
 70e:	06 2e       	mov	r0, r22
 710:	02 c0       	rjmp	.+4      	; 0x716 <DIO_read+0x4e>
 712:	22 0f       	add	r18, r18
 714:	33 1f       	adc	r19, r19
 716:	0a 94       	dec	r0
 718:	e2 f7       	brpl	.-8      	; 0x712 <DIO_read+0x4a>
 71a:	87 2f       	mov	r24, r23
 71c:	90 e0       	ldi	r25, 0x00	; 0
 71e:	82 23       	and	r24, r18
 720:	93 23       	and	r25, r19
 722:	02 c0       	rjmp	.+4      	; 0x728 <DIO_read+0x60>
 724:	95 95       	asr	r25
 726:	87 95       	ror	r24
 728:	6a 95       	dec	r22
 72a:	e2 f7       	brpl	.-8      	; 0x724 <DIO_read+0x5c>
 72c:	fa 01       	movw	r30, r20
 72e:	80 83       	st	Z, r24
		break;
 730:	08 95       	ret
	case PORT_C:
		GET_STATE(*value, PINC, pinNumber); // get state --> read bit
 732:	73 b3       	in	r23, 0x13	; 19
 734:	81 e0       	ldi	r24, 0x01	; 1
 736:	90 e0       	ldi	r25, 0x00	; 0
 738:	9c 01       	movw	r18, r24
 73a:	06 2e       	mov	r0, r22
 73c:	02 c0       	rjmp	.+4      	; 0x742 <DIO_read+0x7a>
 73e:	22 0f       	add	r18, r18
 740:	33 1f       	adc	r19, r19
 742:	0a 94       	dec	r0
 744:	e2 f7       	brpl	.-8      	; 0x73e <DIO_read+0x76>
 746:	87 2f       	mov	r24, r23
 748:	90 e0       	ldi	r25, 0x00	; 0
 74a:	82 23       	and	r24, r18
 74c:	93 23       	and	r25, r19
 74e:	02 c0       	rjmp	.+4      	; 0x754 <DIO_read+0x8c>
 750:	95 95       	asr	r25
 752:	87 95       	ror	r24
 754:	6a 95       	dec	r22
 756:	e2 f7       	brpl	.-8      	; 0x750 <DIO_read+0x88>
 758:	fa 01       	movw	r30, r20
 75a:	80 83       	st	Z, r24
		break;
 75c:	08 95       	ret
	case PORT_D:
		GET_STATE(*value, PIND, pinNumber); // get state --> read bit
 75e:	70 b3       	in	r23, 0x10	; 16
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	90 e0       	ldi	r25, 0x00	; 0
 764:	9c 01       	movw	r18, r24
 766:	06 2e       	mov	r0, r22
 768:	02 c0       	rjmp	.+4      	; 0x76e <DIO_read+0xa6>
 76a:	22 0f       	add	r18, r18
 76c:	33 1f       	adc	r19, r19
 76e:	0a 94       	dec	r0
 770:	e2 f7       	brpl	.-8      	; 0x76a <DIO_read+0xa2>
 772:	87 2f       	mov	r24, r23
 774:	90 e0       	ldi	r25, 0x00	; 0
 776:	82 23       	and	r24, r18
 778:	93 23       	and	r25, r19
 77a:	02 c0       	rjmp	.+4      	; 0x780 <DIO_read+0xb8>
 77c:	95 95       	asr	r25
 77e:	87 95       	ror	r24
 780:	6a 95       	dec	r22
 782:	e2 f7       	brpl	.-8      	; 0x77c <DIO_read+0xb4>
 784:	fa 01       	movw	r30, r20
 786:	80 83       	st	Z, r24
 788:	08 95       	ret

0000078a <interrupt_rising_init>:
		inputs: none
		outputs: none
		return: none
	*/
	// 1. Enable global interrupt(setting bit 7 in status register to 1
	sei();
 78a:	78 94       	sei
	// 2. Choosing the external interrupt snese (sense on the rising edge)
	MCUCR |= (1 << 0) | (1 << 1);
 78c:	85 b7       	in	r24, 0x35	; 53
 78e:	83 60       	ori	r24, 0x03	; 3
 790:	85 bf       	out	0x35, r24	; 53
	// 3.Enable External interrupt 0(INT0)
	GICR |= (1 << 6);
 792:	8b b7       	in	r24, 0x3b	; 59
 794:	80 64       	ori	r24, 0x40	; 64
 796:	8b bf       	out	0x3b, r24	; 59
 798:	08 95       	ret

0000079a <TIMER_init>:
 */
#include "timer.h"
void TIMER_init(void)
{
    // 1. set timer mode to normal mode
    TCCR0 = 0X00; // Normal mode
 79a:	13 be       	out	0x33, r1	; 51
    // 2. Set timer initial value to 0
    TCNT0 = 0x00;
 79c:	12 be       	out	0x32, r1	; 50
 79e:	08 95       	ret

000007a0 <TIMER_start>:
}
void TIMER_start(uint16_t preScalar, uint32_t number_of_overflow)
{
    uint32_t overflowCounter = 0;
    switch (preScalar)
 7a0:	80 34       	cpi	r24, 0x40	; 64
 7a2:	91 05       	cpc	r25, r1
 7a4:	b9 f0       	breq	.+46     	; 0x7d4 <TIMER_start+0x34>
 7a6:	30 f4       	brcc	.+12     	; 0x7b4 <TIMER_start+0x14>
 7a8:	81 30       	cpi	r24, 0x01	; 1
 7aa:	91 05       	cpc	r25, r1
 7ac:	59 f0       	breq	.+22     	; 0x7c4 <TIMER_start+0x24>
 7ae:	08 97       	sbiw	r24, 0x08	; 8
 7b0:	69 f0       	breq	.+26     	; 0x7cc <TIMER_start+0x2c>
 7b2:	13 c0       	rjmp	.+38     	; 0x7da <TIMER_start+0x3a>
 7b4:	81 15       	cp	r24, r1
 7b6:	21 e0       	ldi	r18, 0x01	; 1
 7b8:	92 07       	cpc	r25, r18
 7ba:	91 f0       	breq	.+36     	; 0x7e0 <TIMER_start+0x40>
 7bc:	81 15       	cp	r24, r1
 7be:	94 40       	sbci	r25, 0x04	; 4
 7c0:	99 f0       	breq	.+38     	; 0x7e8 <TIMER_start+0x48>
 7c2:	0b c0       	rjmp	.+22     	; 0x7da <TIMER_start+0x3a>
    {
    case 1:
        TCCR0 |= (1 << 0); // set pin0
 7c4:	83 b7       	in	r24, 0x33	; 51
 7c6:	81 60       	ori	r24, 0x01	; 1
 7c8:	83 bf       	out	0x33, r24	; 51
        break;
 7ca:	07 c0       	rjmp	.+14     	; 0x7da <TIMER_start+0x3a>
    case 8:
        TCCR0 |= (1 << 1); // set pin1
 7cc:	83 b7       	in	r24, 0x33	; 51
 7ce:	82 60       	ori	r24, 0x02	; 2
 7d0:	83 bf       	out	0x33, r24	; 51
        break;
 7d2:	03 c0       	rjmp	.+6      	; 0x7da <TIMER_start+0x3a>
    case 64:
        TCCR0 |= 3; // set pin0 and pin1
 7d4:	83 b7       	in	r24, 0x33	; 51
 7d6:	83 60       	ori	r24, 0x03	; 3
 7d8:	83 bf       	out	0x33, r24	; 51
    TCCR0 = 0X00; // Normal mode
    // 2. Set timer initial value to 0
    TCNT0 = 0x00;
}
void TIMER_start(uint16_t preScalar, uint32_t number_of_overflow)
{
 7da:	20 e0       	ldi	r18, 0x00	; 0
 7dc:	30 e0       	ldi	r19, 0x00	; 0
 7de:	10 c0       	rjmp	.+32     	; 0x800 <__DATA_REGION_LENGTH__>
        break;
    case 64:
        TCCR0 |= 3; // set pin0 and pin1
        break;
    case 256:
        TCCR0 |= (1 << 2); // set pin2
 7e0:	83 b7       	in	r24, 0x33	; 51
 7e2:	84 60       	ori	r24, 0x04	; 4
 7e4:	83 bf       	out	0x33, r24	; 51
        break;
 7e6:	f9 cf       	rjmp	.-14     	; 0x7da <TIMER_start+0x3a>
    case 1024:
        TCCR0 |= 5; // set pin0 and pin2
 7e8:	83 b7       	in	r24, 0x33	; 51
 7ea:	85 60       	ori	r24, 0x05	; 5
 7ec:	83 bf       	out	0x33, r24	; 51
        break;
 7ee:	f5 cf       	rjmp	.-22     	; 0x7da <TIMER_start+0x3a>
    }
    // Repeated number of overflow times
    while (overflowCounter < number_of_overflow)
    {
        // wait the overflow flat to be set
        while ((TIFR & (1 << 0)) == 0);
 7f0:	08 b6       	in	r0, 0x38	; 56
 7f2:	00 fe       	sbrs	r0, 0
 7f4:	fd cf       	rjmp	.-6      	; 0x7f0 <TIMER_start+0x50>
        // Clear the overflow flag
        TIFR |= (1 << 0);
 7f6:	88 b7       	in	r24, 0x38	; 56
 7f8:	81 60       	ori	r24, 0x01	; 1
 7fa:	88 bf       	out	0x38, r24	; 56
        overflowCounter++;
 7fc:	2f 5f       	subi	r18, 0xFF	; 255
 7fe:	3f 4f       	sbci	r19, 0xFF	; 255
    default:
        // Error handling
        break;
    }
    // Repeated number of overflow times
    while (overflowCounter < number_of_overflow)
 800:	26 17       	cp	r18, r22
 802:	37 07       	cpc	r19, r23
 804:	a8 f3       	brcs	.-22     	; 0x7f0 <TIMER_start+0x50>
        while ((TIFR & (1 << 0)) == 0);
        // Clear the overflow flag
        TIFR |= (1 << 0);
        overflowCounter++;
    }
}
 806:	08 95       	ret

00000808 <TIMER_stop>:
void TIMER_stop(void)
{
    // Timer stop
    TCCR0 = 0x00;
 808:	13 be       	out	0x33, r1	; 51
 80a:	08 95       	ret

0000080c <delay_5s>:
}

void delay_5s(void)
{
	TIMER_start(256, 77);
 80c:	6d e4       	ldi	r22, 0x4D	; 77
 80e:	70 e0       	ldi	r23, 0x00	; 0
 810:	80 e0       	ldi	r24, 0x00	; 0
 812:	91 e0       	ldi	r25, 0x01	; 1
 814:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <TIMER_start>
	TIMER_stop();
 818:	0e 94 04 04 	call	0x808	; 0x808 <TIMER_stop>
 81c:	08 95       	ret

0000081e <__umulhisi3>:
 81e:	a2 9f       	mul	r26, r18
 820:	b0 01       	movw	r22, r0
 822:	b3 9f       	mul	r27, r19
 824:	c0 01       	movw	r24, r0
 826:	a3 9f       	mul	r26, r19
 828:	70 0d       	add	r23, r0
 82a:	81 1d       	adc	r24, r1
 82c:	11 24       	eor	r1, r1
 82e:	91 1d       	adc	r25, r1
 830:	b2 9f       	mul	r27, r18
 832:	70 0d       	add	r23, r0
 834:	81 1d       	adc	r24, r1
 836:	11 24       	eor	r1, r1
 838:	91 1d       	adc	r25, r1
 83a:	08 95       	ret

0000083c <_exit>:
 83c:	f8 94       	cli

0000083e <__stop_program>:
 83e:	ff cf       	rjmp	.-2      	; 0x83e <__stop_program>
